import numpy

# Конкретный пример использования симплекс-метода на определённой целевой функции и целевых условиях
# F(x1, x2, x3, x4) = x1 + x2 + x3 - x4 -> max
# x1 + x2 + 2x3 + x4 >= 12
# x1 + 2x2 + x3 >= 20
# x1 + x2 + x3 >= 20
# x1 >= 0
# x2 >= 0
# x3 >= 0
# x4 >= 0

# Важно! Данный симплекс-метод работает для тех целевых условий и целевой функции, у которых знак целевых условий >= !

# функция, которая выполняет алгоритм симплекс-метода для нахождения максимума целевой функции, а также максимальных значений переменных системы целевых условий
def simplex_method(A, b, c):
    # определение размерности массива A
    m, n = A.shape
    # определение массива индексов базисных переменных
    B = numpy.arange(n - m, n)
    # определение массива индеков небазисных переменных
    N = numpy.arange(n - m)

    # бесконечный цикл для выполнения итераций симплекс-метода
    while True:
        # вычисление обратного массива для массива A с использованием индексов базисных переменных массива B
        B_inv = numpy.linalg.inv(A[:, B])
        # вычисление значений базисных переменных
        x_B = B_inv @ b
        # создание массива для хранения значений переменных целевой функции и системы целевых условий
        x = numpy.zeros(n)
        # присваивание значениям базисных переменных соответствующих элементов массива x
        x[B] = x_B
        # выбор коэффициентов целевой функции, соответствующих базисным переменным
        c_B = c[B]
        # выбор коэффициентов целевой функции, соответствующих небазисным переменным
        c_N = c[N]
        # вычисление вектора оценок небазисных переменных
        r_N = c_N - A[:, N].T @ B_inv @ A[:, B] @ c_B

        # проверка условия оптимальности решения
        if numpy.all(r_N >= 0):
            # выход из цикла, если выполнено условие оптимальности
            break

        # выбор индекса небазисной переменной с наименьшей оценкой
        j = N[numpy.argmin(r_N)]
        # вычисление вектора d, необходимо для нахождения разрешающего столбца
        d = B_inv @ A[:, j]

        # проверка условия неограниченности целевой функции
        if numpy.all(d <= 0):
            # выход из функции кода "simplex_method", если целевая функция не ограничена
            return None

        # вычисление отношений значений базисных переменных к соответствующим значениям вектора d
        x_Bd = x_B / d
        # замена отрицательных отношений на бесконечность
        x_Bd[x_Bd < 0] = numpy.inf
        # выбор индекса базисной переменной, связанной с наименьшим отношением вектора x_B к вектору d
        i = B[numpy.argmin(x_Bd)]
        # замена индекса базисной переменной в массиве B
        B[B == i] = j
        # замена индекса небазисной переменной в массиве N
        N[N == j] = i
    # возврат значений переменных целевой функции и системы целевых условий
    return x

# функция кода, находящая максимум целевой функции, а также максимальные значения переменных системы целевых условий
def simplex_method_maximum(A, b, c):
    # вызов функции кода "simplex_method"
    maximum = simplex_method(A, b, c)
    # проверка условия неограниченности целевой функции
    if maximum is None:
        print('Функция не ограничена!')
    else:
        print('Максимальное значение функции:', c @ maximum)
        print('Максимальное значение переменных системы линейных уравнений равны:', maximum)

# массив значений козффициентов левой части системы целевых условий
A = numpy.array([[1, 1, 2, 1], [1, 2, 1, 0], [1, 1, 1, 0]])

# массив значений коэффициентов правой части системы целевых условий
b = numpy.array([12, 20, 20])

# массив значений коэффициентов целевой функции
c = numpy.array([1, 1, 1, -1])

# вызов функции кода и вывод результата в консоль
simplex_method_maximum(A, b, c)